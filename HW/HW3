Problem 1: Insertion Sort
  For insertion sort, we have an array of integers ranging to an infinite number of them. 
It takes an action to take the integer out of the array and set it as an element out of the array.
As the array grows, that will take the same amount of steps, n. So from there, it would already be O(n). 
Now that same integer has to compare to every integer to the left of the array (closer index to 0) until 
it finds its index. That takes another amount of steps, n. In this case, the average would be BigTheta(n^2)
So this would be the worst-case scenario O(n^2). The best-case scenario would be BigOmega(n). This is only
possible if all the numbers in the array are already put in order so we go through each integer comparing 
to the left without having to move. In the worst-case scenario where the array is set from biggest to smallest
and we have to compare every number, it will still be O(n^2)
The time complexity for Insertion sort is:
  O(n^2)
  BigOmega(n)
  BigTheta(n^2)

Problem 2: Matrix Multiplication
  In this case, we have three for loops. A for loop that increases by one and goes to the end
of an array takes O(n) time. Since we have three for loops, the worst-case scenario would give 
us O(n^3). The best-case and average-case scenario would still be BigOmega(n^3) and BigTheta(n^3)
because you still have to go through every element in each column and row to be multiplied and
added to the sum which is printed at the end
The time complexity for Matrix Multiplication is:
  O(n^3)
  BigOmega(n^3)
  BigTheta(n^3)
